# Routing



![router](./routing_img/router.png)

## 라우팅(Routing)이란?

- 어떤 네트워크 안에서 통신 데이터를 보낼 **<u>경로를 선택하는 과정</u>** (네트워크 개념)
- "선택하는 과정" - **선택이 일어나는 일련의 처리과정**



## 선택(Condition)

- 프로그래밍에서 선택이란 어떤 **상태**를 선택하는 것  프로그래밍에서의 선택이란 곧 **condition**
- 이는 마치 잠을 잘까 밥을 먹을까의 선택을 하는 것이 아니라, (주어진 상태에 따라)배고프면 밥을 먹고, 졸리면 잠을 잔다는 것이 프로그래밍
- 그렇다면 프로그래밍에서의 선택이 상태고 이를 라우팅과 결합해보면 라우팅은 **상태에 따라 일어나는 일련의 처리과정**

 

## 조건문(Conditional Statement)

- 조건이란 **주어진 상태**라는 뜻

- 주어진 상태에 따라 다른 처리를 선택하기 때문에 **조건에 따라 달리 선택되는 문**이라는 의미로 조건문입니다.

- 이는 곧 '상태에 따라 일어나는 처리과정' 이라는 라우팅의 정의와 동일함

  

## 조건문의 제거

- 프로그래밍의 가장 큰 문제는 복잡성 

  >  지금 이야기하는 복잡성은 컴퓨터 입장에서의 시간 복잡도를 이야기 하는 것이 아니라, **<u>인간이</u>** 코드를 이해하는 데에 있어서 발생하는 복잡성을 의미

-  2단 중첩문 이상에서 인간의 이해도는 급격히 하락. 안정성이 떨어짐.
- 하지만 알고리즘에서 조건문은 결코 제거될 수 없고, 조건문을 제거하지 않으면 복잡성은 제거되지 않음



근본적인 해결책은 아니나, 조선문을 분산시키는 기술이 존재. 이는 미리 조건에 해당되는 데이터를 구비해 놓는 방법. 

```swift
switch( a ){
	case 'print':   /*statement1*/ break
	case 'action':  /*statement2*/ break
	case 'run': 	/*statement3*/ break
	case 'stop': 	/*statement4*/ break
}

```

```swift
var actor = {
print : function(){ /*statement1*/ },
action : function(){ /*statement2*/ },
run : function(){ /*statement3*/ },
stop : function(){ /*statement4*/ }
};

var runner = actor[a];
runner();
```



- 함수 해쉬를 사용해, switch문에 있던 모든 조건에 대응하는 키에 함수를 할당하여 조건별 처리되던 문을 각각의 함수 내부로 옮김.
- 전략패턴, 상태패턴, 방법론, Data Driven. 상태에 따른 행동의 캡슐화. 
- 기존의 switch문에서는 조건이 늘어나면 매번 코드를 건드려야하지만, 경우의 수만큼 데이터화한 경우는 새로운 경우에 대한 데이터를 추가함으로서 처리됨.

```swift
//switch
switch(a){
...
case 'handle': ....; break;
}
 
//data
actor.handle = function(){...};
```

- 코드의 확장, 수정이 훨씬 간편해짐. 코드를 건드려 수정배포 할 필요가 없이, 단순히 새로운 데이터를 추가해주기만 하면 됨. 



## 라우팅

```swift
var runner = actor[a];
```

- **상태에 따라 일어나는 일련의 처리과정**을 훌륭하게 커버하고 있다.
- 이때 상태는 'a' 이고 일련의 처리과정에 해당되는 녀석은 'runner'입니다.
- 프로그래밍에서 등장하는 라우터는 코드의 복잡성을 제거하고 디자인을 데이터드리븐 방식으로 변경하기 위해 기존의 조건문을 일관된 처리객체와의 매핑으로 바꾸는 과정에서 만들어지는 산출물.
- 라우터와 조건문의 차이는 '매핑 규칙'

 

## 매핑규칙(Mapping Rule)

- 조건문의 조건식에 들어갈 내용을 정형화하여 간단한 규칙으로 만든 것

```swift
var runner = actor[a];
```

- 이는 a라는 값이 뭐가 되었든 actor에 정의만 되어있으면 된다는 엄청나게 간단한 규칙. 이 때의 문제는 a에 해당되는 키가 actor에 없으면 안되다는 것이지만, 안정성은 둘째치고 규칙은 엄청나게 간단하고 확장도 무한. (실행시점의 안정성은 결국 try로 확보할 수 밖에 없습니다)
- 매핑규칙과 조건식의 근본적인 차이점은 조건의 확장성. 조건식이 되면 코드를 수정하지 않고는 확장성이 거의 없어지게 됩니다. 

 

## 트리거, 테이블, 타겟, 규칙

1. 규칙(Rule) 	  : 위 코드에서 라우팅이 되는 일종의 규칙. 전체적인 얼개 (테이블과 동시에 테이블 안에서 정의됨)
2. 타겟(Target)      : 위 코드상에서의 상태. 'a'
3. 테이블(Table)    : 상태, 즉 타겟이 매핑될 (해쉬)테이블, 위 코드에서의 'actor'.
4. 트리거(Trigger) : 라우터의 작동이 언제 일어날 지를 정의함. 변화를 인식하는 시점. 

- 라우팅 테이블 안에 규칙을 포함하고 타겟을 넘겨주는 게 일반적인 구조



## 요약



라우팅, 매핑이라는 디자인 패턴은 곧

조건문에서의 각각의 행동(statement)을 의미하는 각각의 함수를

자료구조, 프레임워크 내의 **<u>원소</u>**로서 인식하는 사고의 전환

**조건(상태)과 함수를 하나의 해쉬 테이블 내 '규칙'이자 Key-Value의 관계 속에서 인식하고 이를 통해 확장성을 높이는 것**

기존의 한정적이고 복잡한 조건문의 구조를 확장성/유연성을 갖는 라우팅의 구조로 개편하는 것. 



타겟(인자)를 기준으로 알맞은 규칙이 정해지고, 이는 해쉬처럼 라우팅 테이블로 알맞게 매핑된다.

각각의 타겟과 매핑 시점을 판단하는 트리거는 필시 Observable 패턴을 이용할 것 (Reactive)

> 만약 RxSwift를 공부하며 함수형/반응형 소프트웨어 디자인에 익숙해지게 된다면. 그와 같은 프로그래밍 패러다임 속에 녹아있는 라우팅 패턴을 한 번 집중해서 찾아보자. 





## Reference

http://www.bsidesoft.com/?p=123